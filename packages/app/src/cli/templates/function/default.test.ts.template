import { describe, test, expect } from "vitest";
import path from "path";
import fs from "fs";
import { exec } from "child_process";
import { promisify } from "util";

const execAsync = promisify(exec);

async function loadFixture(fixturePath: string) {
  try {
    const fixtureContent = await fs.promises.readFile(fixturePath, 'utf-8');
    const fixture = JSON.parse(fixtureContent);

    return {
      name: fixture.name,
      export: fixture.export,
      query: fixture.query,
      input: fixture.input,
      expectedOutput: fixture.output,
    };
  } catch (error) {
    if (error instanceof SyntaxError) {
      throw new Error(`Invalid JSON in fixture file ${fixturePath}: ${error.message}`);
    } else if (error instanceof Error) {
      throw new Error(`Failed to load fixture file ${fixturePath}: ${error.message}`);
    } else {
      throw new Error(`Unknown error loading fixture file ${fixturePath}`);
    }
  }
}

async function runFunctionRunner(wasmPath: string, exportName: string, input: any) {
  try {
    // Create a temporary input file
    const inputFile = path.join(__dirname, 'temp-input.json');
    await fs.promises.writeFile(inputFile, JSON.stringify(input, null, 2));

    // Run the shopify app function run command with JSON output
    // We need to run from the app root directory and specify the function path
    const appRootDir = path.dirname(path.dirname(__dirname)); // Go up from tests/function-name to app root
    const functionName = path.basename(path.dirname(__dirname)); // Get function name from path
    const command = `shopify app function run --input ${inputFile} --export ${exportName} --json --path ${functionName}`;
    const workingDir = appRootDir;

    const { stdout, stderr } = await execAsync(command, { cwd: workingDir });

    // Clean up temporary file
    await fs.promises.unlink(inputFile).catch(() => {});

    // Try to parse the output as JSON
    let result: any;
    try {
      result = JSON.parse(stdout);

      // Handle the function execution result structure
      console.log('Raw result:', JSON.stringify(result, null, 2));

      let actualOutput;
      if (result && result.output && result.output.humanized) {
        // The output field contains humanized data
        try {
          actualOutput = JSON.parse(result.output.humanized);
        } catch (humanizedParseError) {
          actualOutput = result.output.humanized;
        }
      } else if (result && result.humanized) {
        // The result itself contains humanized data
        try {
          actualOutput = JSON.parse(result.humanized);
        } catch (humanizedParseError) {
          actualOutput = result.humanized;
        }
      } else if (result && result.output) {
        // Use the output field directly
        actualOutput = result.output;
      } else {
        // Use the entire result
        actualOutput = result;
      }

      result = { output: actualOutput };
    } catch (parseError) {
      // If JSON parsing fails, return the raw output
      console.warn('Function run did not return valid JSON, using raw output');
      return {
        result: { output: stdout.trim() },
        error: null,
      };
    }

    return {
      result,
      error: null,
    };
  } catch (error) {
    // Clean up temporary file if it exists
    const inputFile = path.join(__dirname, 'temp-input.json');
    await fs.promises.unlink(inputFile).catch(() => {});

    console.log('=== ERROR DETAILS ===');
    console.log('Error:', error);
    console.log('Error type:', typeof error);
    if (error instanceof Error) {
      console.log('Error message:', error.message);
      console.log('Error stack:', error.stack);
    }
    console.log('=====================');

    if (error instanceof Error) {
      return {
        result: null,
        error: error.message,
      };
    } else {
      return {
        result: null,
        error: 'Unknown error occurred',
      };
    }
  }
}


// Keeping these as a placeholder for now, can add more validation later
async function validateInputShape(input: any, exportName: string, dirname: string) {
  expect(() => JSON.stringify(input)).not.toThrow();
  expect(input).toBeDefined();
  expect(typeof input).toBe('object');
  expect(input).not.toBeNull();
}

// Keeping these as a placeholder for now, can add more validation later
async function validateOutputShape(output: any, exportName: string, dirname: string) {
  expect(() => JSON.stringify(output)).not.toThrow();
  expect(output).toBeDefined();
  expect(typeof output).toBe('object');
  expect(output).not.toBeNull();
}

describe("Default Integration Tests", () => {
  const wasmPath = path.join(
    __dirname,
    "../target/wasm32-wasip1/release/discount-function.wasm"
  );
  const fixturesDir = path.join(__dirname, "fixtures");
  const fixtureFiles = fs
    .readdirSync(fixturesDir)
    .filter((file) => file.endsWith(".json"))
    .map((file) => path.join(fixturesDir, file));

  fixtureFiles.forEach((fixtureFile) => {
    test(`runs ${path.relative(fixturesDir, fixtureFile)}`, async () => {
      const fixture = await loadFixture(fixtureFile);

      await validateInputShape(fixture.input, fixture.export, __dirname);
      await validateOutputShape(fixture.expectedOutput, fixture.export, __dirname);

      const { result, error } = await runFunctionRunner(
        wasmPath,
        fixture.export,
        fixture.input
      );

      expect(error).toBeNull();
      expect(result.output).toEqual(fixture.expectedOutput);
    });
  });
});


